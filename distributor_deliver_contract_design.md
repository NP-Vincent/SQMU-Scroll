# Designing an ERC-7683-Compatible **Distributor.deliver** Contract

## Introduction

In cross-chain applications, **ERC-7683 "Intents"** provide a standardized way for users to request complex cross-chain actions with a single **intent** (user request) instead of manually bridging and executing on each chain. ERC-7683 defines common data structures and interfaces for such cross-chain value transfers, enabling different protocols to interoperate. In our case, we want a **Distributor** smart contract for the **SQMU token sell dApp** that leverages ERC-7683 intents and integrates with **Across+** (Across Protocol’s bridging SDK) for cross-chain payments. The goal is to allow a user on one chain to pay (e.g. with a stablecoin) and receive SQMU tokens on another chain seamlessly, using the intents-based approach. The Distributor contract must meet several key requirements (as provided by the user):

1. **ERC-7683 Compliance:** Yes – the contract should conform to the ERC-7683 intent standard (compatible interfaces and flows).
2. **Treasury-Only Token Transfers:** Only transfer pre-minted SQMU tokens from a designated treasury address (no minting in this contract).
3. **Across+ Bridge for Payments:** Rely on Across Protocol (Across+) to handle cross-chain payment bridging (the user’s payment will be bridged).
4. **Trusted Relayer Restriction:** For now, only Across’s mechanism is allowed to trigger token delivery (later we can allow a whitelisted relayer set).
5. **Upgradeable Design:** Make the contract upgradeable via proxy, so its logic can evolve as requirements change.

Below we break down how to design the Distributor contract to satisfy these requirements while citing relevant standards and Across protocol documentation.

## ERC-7683 Intents and Across Protocol Integration

**ERC-7683** introduces a standard API for cross-chain settlement. It provides a generic `CrossChainOrder` struct for user intents and defines **settlement interfaces** for origin and destination contracts. In particular, an **IOriginSettler** interface (on the source chain) handles opening intents and escrow of funds, and an **IDestinationSettler** interface (on the destination chain) handles fulfilling intents (releasing funds/tokens to the user). The Across Protocol has implemented this standard in its V4 design: the **AcrossOriginSettler** contract on source chains implements IOriginSettler, and each **SpokePool** (bridge contract on destination chains) implements IDestinationSettler.

**Across+ (Across V4)** effectively uses ERC-7683 behind the scenes. When a user declares an intent (e.g. “bridge X tokens from Chain A to Chain B”), the AcrossOriginSettler validates the intent and **processes it by creating a deposit** into the Across bridge (SpokePool). This deposit represents the cross-chain transfer. On the destination side, the SpokePool (which implements the standard destination settlement interface) will handle the fill and release funds accordingly. In Across V4, they extend this with **embedded crosschain actions**, meaning the bridge can carry an extra *message* and call a custom contract on the destination once funds arrive. We will leverage this feature to have the **Distributor** contract automatically deliver SQMU tokens when the bridged payment arrives.

**Intent Flow Overview:** In our design, a user on the source chain will effectively express an “intent” to buy SQMU on the destination chain. The user’s **payment (e.g. stablecoins)** will be sent across via Across’s bridge, and on the destination chain the Distributor contract will be invoked to deliver the SQMU tokens. The beauty of ERC-7683 intents is that the user doesn’t manually orchestrate these steps – they simply request the end result (swap/bridge) and **relayers** compete to fulfill it efficiently. Across+ will handle the bridging mechanics, allowing our dApp to abstract away complexity from the user.

## Distributor Contract Design

### 1. **Token Distribution from Treasury Only**

The Distributor contract **will not mint** any new SQMU tokens; it only transfers tokens that have been pre-minted and set aside for this distribution (held in a treasury address or the contract itself). This is a security and supply-control measure – the contract cannot inflate the token supply. Instead, a **treasury address** (for example, a multi-sig or the contract’s own balance) will hold all SQMU tokens allocated for the sale. The Distributor contract will be authorized to transfer tokens from this treasury to buyers. In practice, the treasury could approve the contract as a spender of SQMU, or the tokens might be initially deposited in the contract. Either way, when fulfilling a sale the contract will call the SQMU token’s `transferFrom(treasury, user, amount)` or `IERC20.transfer(user, amount)` using its holdings. By restricting to pre-minted supply, we ensure the contract only **distributes existing tokens**, aligning with point (2). This approach is analogous to how Across uses relayer-provided liquidity rather than minting new tokens: the relayer provides the bridged funds from an existing pool and is later reimbursed (similarly, our contract provides tokens from a preset pool rather than minting on demand).

### 2. **Handling Payments via Across Bridge (Across+)**

User payments will be handled through Across+, meaning the user’s payment on the origin chain is **bridged** to the destination. We assume the user will pay in a specific token (e.g. USDC or ETH) on the source chain to buy SQMU. Using Across’s SDK and contracts, this works as follows:

- On the source chain, the dApp (via Across+ SDK) creates an **Across deposit** for the payment. This could either be done by directly calling Across’s SpokePool deposit (e.g. `depositV3`) or by utilizing the ERC-7683 **OriginSettler** flow (e.g. calling `AcrossOriginSettler.open(order)` with an OnchainCrossChainOrder). In either case, the deposit will include: the token and amount being sent, the destination chain, the **recipient contract address** (our Distributor on the destination), and an optional **message** payload. Across’s docs provide a step-by-step example of generating such a cross-chain intent and deposit.

- Crucially, we will set the **recipient** of the Across deposit to be the Distributor contract on the destination chain, and include a message that encodes needed info (e.g. the buyer’s address). For example, if using Across’s custom message functionality, we craft a message containing the user’s address (and possibly the exact SQMU amount to deliver, or any flags needed). Across’s deposit API supports attaching this message and will pass it along to the destination.

- When a relayer fulfills the bridge transfer, the Across destination **SpokePool** will deliver the funds and call our Distributor’s handler function with the included message. Specifically, Across expects the **Distributor contract to implement** the function `handleV3AcrossMessage(address tokenSent, uint256 amount, address relayer, bytes memory message)`. This is the hook by which custom logic is executed upon funds arrival. Our contract will implement this as the core **delivery** function.

**Implementing ********`handleV3AcrossMessage`********:** Inside this function, the Distributor contract will finalize the sale: it will **verify the call is from Across** and then transfer SQMU tokens to the user. For security, we *must ensure only the Across bridge contract can call this function*. We can store the Across **SpokePool** contract address (for the relevant destination chain) as an immutable or in storage during initialization. On function entry, the contract checks `if (msg.sender != acrossSpokePool) revert Unauthorized();` – this pattern is shown in Across’s own examples. This guarantees that an attacker cannot spoof a cross-chain call; only a legitimate bridge fulfillment can trigger token delivery.

After verification, the contract will decode the `message` to get the target user address (and any other info encoded). For example, if our message was simply `abi.encode(userAddress)`, we decode it to an address. Then the contract calculates how many SQMU tokens to deliver. This amount might be predetermined: it could equal the bridged payment amount if 1:1 pricing, or use a price formula (for instance, if 1 USDC pays for 1 SQMU, then deliver `amount` of SQMU). The pricing logic can be built-in or the exact token amount could even be encoded in the message by the frontend. Using the bridging **`amount`** directly is recommended rather than trusting the message for payment info (Across docs advise using the `tokenSent` and `amount` parameters as they are enforced by the bridge contract and thus reliable). For instance, if the sale price is fixed, the dApp could ensure the user’s deposit amount corresponds to the desired SQMU output and simply encode the user’s address in the message. The contract would then transfer that same `amount` of SQMU to the user (or apply a conversion if needed).

Finally, the Distributor uses the SQMU token’s ERC-20 interface to transfer tokens from the treasury to the user’s address. This completes the cross-chain intent: the user’s intent of exchanging their asset on Chain A for SQMU on Chain B is fulfilled in one atomic flow from the user’s perspective.

### 3. **Restricting to Across Relayers (Trust Model)**

In the initial version, we only trust Across’s system to relay intents. That means we **do not allow arbitrary callers or relayers** to invoke the delivery. As described above, the `handleV3AcrossMessage` function checks that `msg.sender` is the Across SpokePool contract – the SpokePool is the contract that *initiates* the call on the destination when a relay is fulfilled. By tying the function to Across’s official contract, we effectively restrict fulfillment to Across’s relayer network only (since only a valid Across relayer can trigger the SpokePool to call us).

However, it’s important to note that **Across’s design does involve trusting relayers to some extent**. Across ensures that if a relayer delivers incorrect or malicious message data, they simply won’t get reimbursed, but it **does not guarantee the integrity of the message payload itself**. In other words, if our contract blindly trusted the `message`, a relayer could try to spoof it (though they’d lose money if the protocol catches the discrepancy). As a safety measure, the Across docs suggest including a **user-signed signature** in the message for critical info, or otherwise treating the message as untrusted data. In our design, we mitigate risk by not relying on the message for the amount of payment (we use the `amount` param which Across guarantees) and by only using the message for the user’s address or predetermined outputs. This way, a relayer cannot, for example, make the contract send tokens to an arbitrary address or change the amount. Still, at this stage we assume Across’s relayer network is honest enough because they are economically incentivized to behave (and possibly because Across+ will be the only integration initially).

### 4. **Future Whitelisted Relayer Support**

As the requirement (4) notes, later on we might want to allow other trusted relayers or bridging systems to trigger the token delivery (not just Across). We can design the contract with **extensibility** in mind for this. There are a couple of approaches for whitelisting relayers in the future:

- **Allow specific addresses to call a direct fill function:** We could implement a function like `deliverDirect(address user, uint256 paymentAmount)` or a standard `fill(bytes32 orderId, bytes originData, bytes fillerData)` (from ERC-7683’s IDestinationSettler) that can be called by certain addresses. We’d maintain a **mapping of approved relayer addresses**, and the function would require `require(approvedRelayer[msg.sender] == true, "Not allowed")` to execute. This idea aligns with the ERC-7683 philosophy: we’d be letting a known solver/filler call a fill on our contract directly, bypassing Across. Across’s documentation explicitly mentions that one can restrict which relayer(s) can complete a fill by whitelisting addresses and checking the `relayer` parameter in the handler call. We could apply a similar pattern in a direct-call function or even within `handleV3AcrossMessage` by additionally validating the `relayer` argument that Across passes in. Essentially, this future change would let us integrate other networks or even our own relay service by trusting specific keys.

- **Switch to a different bridging module:** Because the contract is upgradeable (see next section), we have the flexibility to swap out or augment the Across integration later. For instance, we might deploy a new version that also implements a generalized **IDestinationSettler.fill** function for any ERC-7683 order, or that supports another bridge’s callback interface. In any case, the initial strict `msg.sender == acrossSpokePool` check can later be modified (via upgrade) to accept calls from a set of allowed senders (e.g. multiple SpokePools or a custom relayer contract). Until then, keeping it limited to Across ensures a controlled environment.

The key is that at present we **trust Across’s infrastructure** as the sole fulfiller. Later, by whitelisting, we effectively substitute that trust to one or more chosen parties (which might be necessary if migrating away from Across or incorporating an additional cross-chain router).

### 5. **Upgradability via Proxy**

To allow the Distributor contract to evolve with changing requirements, we will make it **upgradeable** using a proxy pattern. Upgradeable proxies separate the contract’s storage and identity (held in the proxy) from the implementation logic (in a logic/implementation contract). We can use OpenZeppelin’s standard upgradeable proxy approach, which adheres to **EIP-1967** for storage slots and supports either the Transparent or UUPS proxy pattern. In practice, we might deploy a `TransparentUpgradeableProxy` pointing to an initial `DistributorLogic` contract. The proxy’s admin (e.g. our team’s multi-sig) can later update the implementation address to a new contract if we want to add features (such as new relayer logic or emergency fixes).

Using OpenZeppelin’s Upgradeable libraries is recommended to avoid pitfalls in writing upgradeable contracts. We will ensure the Distributor’s logic contract has an `initialize(...)` function (instead of constructor) to set initial state like the treasury address, the Across SpokePool address, etc., since constructors don’t run in proxy context. Additionally, we’ll include access control on the upgrade (only owner can upgrade) by overriding `_authorizeUpgrade` if using UUPS, or by the proxy admin if using TransparentProxy.

**Why upgradeability?** The cross-chain landscape is quickly evolving. Our dApp might need to adjust pricing logic, support new bridge protocols, or respond to security audits. By deploying the Distributor behind a proxy, we can implement requirement (5) and modify the contract later without requiring users to move to a new address. Of course, this introduces a trust assumption (the admin can change contract behavior), so we’ll be transparent about this to users and secure the admin key strongly.

## Putting It All Together

With this design, the **Distributor.deliver** contract will function as follows in a typical user flow:

- A user initiates a sale through the dApp UI, choosing to buy SQMU on the destination chain. The UI (via Across+ SDK) generates an ERC-7683 intent: it prepares the bridging deposit (with the user’s payment token/amount, target chain, and our contract as recipient) and encodes the user’s address in the message. The user signs or submits this transaction on the origin chain (either calling Across’s origin settler or directly the bridge contract as appropriate).
- Across’s relayer network picks up the deposit intent and **fulfills it** by moving the funds to the destination. The Across destination SpokePool then calls `handleV3AcrossMessage` on our Distributor contract, delivering the bridged funds and the message payload.
- Our Distributor contract, upon this call, validates the caller and decodes the message. It then transfers the corresponding **SQMU tokens from the treasury to the user’s address** (and possibly retains the payment tokens as proceeds, e.g. sending the USDC to the project treasury or locking it – this part is application-specific). The `Open` event from the origin and the completion on destination are all part of the standard ERC-7683 flow, meaning the intent was opened and now has been filled/settled.
- The user receives their SQMU on the destination chain without manually bridging or swapping – the intent abstracted those steps away. From the user’s perspective, they just requested a cross-chain swap and it was executed efficiently.

Throughout this process, we adhered to ERC-7683 standards (making our contract interoperable with the intents ecosystem) and used Across Protocol as the **initial settlement layer**. By limiting token transfers to a pre-minted supply, we maintain control over token distribution. By trusting only Across’s contract calls, we reduce exposure to unknown actors. And by making the contract upgradeable, we keep the door open to improving or expanding the system (like adding whitelisted relayers or new functionality) as the project grows.

In summary, the **Distributor.deliver** smart contract will act as a secure, flexible bridge between the user’s cross-chain intent and the actual token delivery, aligning with the latest cross-chain standards and leveraging Across+ for a smooth user experience. This design meets all the specified requirements and is built on proven patterns from ERC-7683 and Across V4.

**Sources:** The ERC-7683 spec and Across Protocol documentation were referenced for standard interfaces and best practices, ensuring our solution is well-grounded in the current state of cross-chain interoperability.





